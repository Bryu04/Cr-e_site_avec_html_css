Structurez votre page

Utilisez la balise  <header> pour l'en-tête

La plupart des sites web possèdent un <header>(en-tête, en français). On y trouve le plus souvent, à minima, un logo. On le place, pour des raisons de cohérence, en tête du code, donc au début de la balise   <body>  :

<header>
<!-- Placez ici le contenu de l'en-tête de votre page -->
</header>

L'en-tête peut contenir tout ce que vous voulez : une image pour un logo, liens, du texte pour le slogan de votre marque par exemple, un bouton d'appel à l'action… Généralement, on préfère que cela reste clair et lisible donc on évite de surcharger le  <header>  avec trop d'éléments.

Voici par exemple l’en-tête du site de La Fourche :

Attention, la balise <header>  n'a rien  à voir avec la balise  <head>  que vous aviez vue dans la première partie :

  - la balise <header>  permet de créer une partie de la page HTML ;

  - la balise  <head>  permet d'inclure des informations générales sur la page, notamment son titre, des liens 
    vers des polices, vers une feuille de style, etc.

Il peut y avoir plusieurs en-têtes dans votre page. Si celle-ci est découpée en plusieurs sections, chaque section peut en effet avoir son propre  <header>  .

Utilisez la balise  <footer>  pour le pied de page

À l'inverse de l'en-tête, le pied de page se trouve tout en bas de la page. On y trouve généralement des informations comme des liens de contact, les mentions légales, la politique de confidentialité, etc.

<footer>
<!-- Placez ici le contenu du pied de page -->
</footer>
Voici le pied de page de la page d’accueil du site de La Fourche :

Utilisez la balise  <nav> pour le menu de navigation

La balise <nav>  doit regrouper tous les principaux liens de navigation du site. Vous y placerez par exemple le menu principal de votre site. Généralement, le menu est réalisé sous forme de liste à l'intérieur de la balise<nav> .

Voici le menu sur le site de La Fourche :

Ici on pourrait avoir, de façon simplifiée :

<nav>
    <ul>
        <li>
            <a href="#">Nouveautés</a>
        </li>
        <li>
            <a href="#">Anti-gaspi</a>
        </li>
        <li>
            <a href="#">Origine France</a>
        </li>
        <li>
            <a href="#">Marque La Fourche</a>
        </li>
    </ul>
</nav>

Utilisez la balise  <main>  pour le contenu principal de la page

La balise <main> permet de déclarer le contenu principal de votre page. Elle englobe la majeure partie du  <body>  d'une page, en excluant les autres éléments tels que le  <header>, le  <footer>  et de potentiels  <aside>. La balise <main> doit être unique : il n'y en a qu'une seule par page :

<main>
</main>

Utilisez des balises  <section>  pour structurer le contenu du  <main>

La balise <section>  sert à regrouper des contenus en fonction de leur thématique. Elle englobe généralement une portion du contenu au centre de la page.

<section>
</section>

Sur la page d'accueil du site de La Fourche, on trouve plusieurs blocs qui pourraient être considérés comme des sections de page :

Utilisez une balise  <aside>  pour des contenus additionnels dans le  main
Il existe d'autres balises pour structurer une page, comme <aside> par exemple, qui permet de contenir des informations complémentaires au document que l'on visualise. Ces informations sont généralement placées sur le côté (bien que ce ne soit pas une obligation). Il peut y avoir plusieurs blocs <aside>  dans la page. Sur Wikipédia, par exemple, il est courant de voir à droite un bloc d'informations complémentaires à l'article que l'on visualise.

À noter : la balise <article>  sert à englober une portion généralement autonome de la page. C'est une partie de la page qui pourrait ainsi être reprise sur un autre site. C'est le cas par exemple des actualités (articles de journaux ou de blogs).

Ne vous y trompez pas : ce schéma propose un exemple d'organisation de la page. Rien ne vous empêche de décider que votre menu de navigation soit à droite, ou tout en haut, que vos balises  <aside>  soient au-dessus, etc.

Essayez d'utiliser toutes les balises que nous venons de découvrir avec le CodePen P3C1.

Ce code peut vous aider à comprendre comment les balises doivent être agencées. Vous y reconnaissez un en-tête, un menu de navigation, un pied de page… et, au centre, deux sections incluses dans  <main>  .

Eh mais… la page ne ressemble à rien, c'est normal ?

Pour l'instant, vous avez juste du texte noir sur fond blanc. C'est normal, il n'y a pas de CSS ! Par contre, la page est bien structurée, ce qui va nous être utile pour la suite. Vous pouvez d'ailleurs totalement appliquer le style souhaité à ces balises, comme vous le feriez pour toutes les balises que vous avez utilisées jusqu'à maintenant.

Je ne comprends pas l'intérêt de ces balises. On peut obtenir le même résultat sans les utiliser, non ?

C'est vrai. En fait, ces balises sont seulement là pour expliquer à l'ordinateur :

“Ceci est l'en-tête”.

“Ceci est mon pied de page”, etc.

Mais qui dit que l'ordinateur comprend veut aussi dire que le contenu sera également plus lisible par des outils d'assistance dans le cadre de l'accessibilité.

Elles n'indiquent pas, contrairement à ce qu'on pourrait penser, où doit être placé le contenu. C'est le rôle du CSS, comme nous le verrons dans peu de temps maintenant.

À l'intérieur de ces balises structurantes, comme vous l'avez sûrement vu dans le bout de code embarqué, vous pouvez également utiliser des balises universelles  <div>  et  <span>  afin de créer des blocs au sein de votre contenu, qui vous permettront ensuite de leur appliquer du style.

À vous de jouer !

C'est le moment de mettre en pratique ce que vous venez d'apprendre dans le portfolio de Robbie Lens. Pour cela, vous allez :

- intégrer un  <header>  dans les pages d'accueil et Á propos ;

- intégrer un  <footer>  dans ces même pages ;

- ajouter  <main>  là où c'est nécessaire ;

- basculer vos liens hypertextes de navigation dans une balise  <nav>  ;

- adapter les déclarations CSS en fonction des modifications faites. 

Comme d'habitude, vous avez accès sur GitHub à la base de code pour faire l’exercice sur la branche P3C1-exercice.

Vous avez trouvé cela difficile ? En cas de doute, consultez la solution sur la branche P3C1-solution.

En résumé

- Plusieurs balises permettent de délimiter les différentes zones qui constituent la page web :

   - <header>  : en-tête ;

   - <footer>  : pied de page ;

   - <nav>  : liens principaux de navigation ;

   - <section>  : section de page ;

   - <aside>  : informations complémentaires ;

   - <article>  : article indépendant.

- Ces balises peuvent être imbriquées les unes dans les autres. Ainsi, une section peut avoir son propre 
  en-tête.

- Ces balises ne s'occupent pas de la mise en page. Elles servent seulement à indiquer à l'ordinateur la 
  fonction du texte qu'elles encadrent. On pourrait très bien placer l'en-tête en bas de la page, si on le 
  souhaitait.

Vous savez maintenant comment structurer correctement vos pages web ! Passons au prochain chapitre : vous allez découvrir le modèle des boîtes, il s'agit d'une autre façon de structurer une page web, mais cette fois à l'aide du CSS, on y va !

##############################################################################################################

Découvrez le modèle des boîtes

Différencier les balises de type  block  et de type  inline

En HTML, la plupart des balises peuvent se ranger dans l'une ou l'autre de ces deux catégories :

  - block: ce type de balise crée automatiquement un retour à la ligne avant et après ; 

  - inline: ce type se trouve obligatoirement à l'intérieur d'une balise  block  . 

Il existe en fait plusieurs autres catégories très spécifiques, par exemple pour les cellules de tableau (type  table-cell  ) ou les puces (type  list-item  ). Nous n'allons pas nous y intéresser pour le moment, car ces balises sont minoritaires.

Pour bien visualiser le concept, voici un petit schéma :

Comme vous pouvez le voir, les blocs sont les uns en dessous des autres. On peut aussi les imbriquer les uns à l'intérieur des autres : souvenez-vous, un bloc  <main>  contient par exemple des blocs  <section>  , qui eux-mêmes peuvent contenir des  <div> .

Quant à la balise  <a></a>  (qui est de type  inline  ), elle se trouve à l'intérieur d'une balise  block  , et le texte vient s'insérer sur la même ligne.

Faites bon usage des balises universelles <span>  et  <div>

J'en profite pour vous parler à nouveau des balises universelles. Vous les connaissez déjà car je vous les ai présentées à plusieurs reprises. Ce sont des balises qui n'ont aucun sens particulier. Le principal intérêt de ces balises est que l'on peut leur appliquer une  class  (ou un  id  ) pour le CSS quand aucune autre balise ne convient.

Il existe deux balises génériques et, comme par hasard, la seule différence entre les deux est que l'une d'elles est  inline  et l'autre est  block  :

    1.La balise<span>(qui est de type inline).

    2.La balise<div>(qui est de type block).

N’abusez pas des balises universelles, même si elles sont utiles dans certains cas : beaucoup de développeurs mettent des  <div>  et des  <span>  trop souvent, et oublient que d'autres balises plus adaptées existent.

Par exemple :

  - <span class="important">  : ici, il ne s'agit pas d'une bonne pratique, alors qu'il existe les balises  
    <strong>   ou  <em>  qui servent à indiquer l'importance ! 

  - <div class="titre">  : idem, cela ne convient pas, puisqu'il existe des balises faites spécialement pour 
    les titres (  <h1>  ,  <h2>  …).

Le résultat visuel est le même, mais les balises génériques n'apportent aucun sens à la page, et ne peuvent pas être comprises par l'ordinateur. Utilisez toujours d'autres balises plus adaptées quand c'est possible.

Maintenant que vous comprenez la différence entre inline et block , nous allons apprendre à dimensionner des éléments en CSS ! Nous allons ici travailler uniquement sur des balises de type  block  .

Pour commencer, intéressons-nous à la taille des blocs.

Dimensionnez les éléments avec width et height

Contrairement à un  inline  , un  block  peut avoir une largeur et une hauteur précises grâce à ces deux propriétés CSS :

  1.width  (largeur du bloc).

  2.height  (hauteur du bloc).

On les exprime en pixels px ou en pourcentage %.

Par défaut, un bloc prend 100 % de la largeur disponible.

On peut le vérifier en appliquant à nos blocs des bordures ou une couleur de fond :

Maintenant, rajoutons un peu de CSS afin de modifier la largeur des paragraphes. Si on veut que tous les paragraphes aient une largeur de 50 %, on écrira en CSS :

p {  
    width: 50%;
}

Le résultat est visible juste en dessous :

Les pourcentages sont utiles pour créer un design qui s'adapte automatiquement à la résolution d'écran du visiteur.

Toutefois, il se peut que vous ayez besoin de créer des blocs ayant une dimension précise en pixels, par exemple pour reprendre un design très précis. Essayez le bout de code suivant pour voir :

p {
    width: 250px;
}

Les images sont un cas un peu particulier : elles se mettent les unes à la suite des autres, sans prendre toute la largeur, mais on peut malgré tout leur donner une dimension exacte.

Définissez des marges avec margin et padding

Tous les blocs possèdent des marges (intérieures et extérieures) :

En CSS, on peut modifier la taille des marges avec deux propriétés :

  1. margin  (taille de la marge extérieure)

  2. padding  (taille de la marge intérieure).

Pour bien comprendre la différence, faisons quelques tests.

Pour l'occasion, j'ai rédigé dans le fichier HTML des paragraphes de texte en lorem ipsum (du faux texte). Ensuite, dans le fichier CSS, j'ai donné au bloc  p  une largeur de  350px  et j'ai ajouté une couleur jaune avec la balise  background-color  pour qu'on visualise bien la différence entre les différentes marges :

p {
    width: 350px;
    background-color: #F1C864;
    text-align: justify;
}

Voilà ce qu'on obtient avec ce code :

Comme vous pouvez le constater, il n'y a par défaut pas de marge intérieure (padding  ) dans le bloc du paragraphe, (on le voit bien car il a un fond jaune et que les bordures sont collées au texte).

En revanche, il y a une marge extérieure (margin  ), on la voit bien car elle espace les paragraphe entre eux, avec une marge blanche (couleur du fond de la page par défaut). C'est cette marge qui fait que deux paragraphes ne sont pas collés, et qu'on a l'impression de “sauter une ligne”.

Ajoutez une marge intérieure avec la propriété CSS  padding
Pour ajouteraux paragraphes une marge intérieure (padding) de  16px  par exemple, on écrit :

p {
    width: 350px;
    background-color: #F1C864;
    text-align: justify;
    padding: 16px;
}

On obtient alors :

Ajoutez une marge extérieure avec la propriété CSS  margin
Maintenant, si on veut que nos paragraphes soient encore plus espacés entre eux, on rajoute la propriété margin  . Demandons par exemple  50px  de marge entre deux paragraphes :

p {
    width: 350px;
    background-color: #F1C864;
    text-align: justify;
    padding: 16px;
    margin: 50px;
}

On obtient :

Mais ??? Une marge s'est rajoutée tout autour aussi, pas seulement entre les deux paragraphes !?

Eh oui, margin  (comme padding  d'ailleurs) s'applique aux quatre côtés du bloc.

Si vous voulez spécifier des marges différentes en haut, en bas, à gauche et à droite, il va falloir utiliser des propriétés plus précises… Le principe est le même que pour la propriété  border, vous allez voir !

Spécifiez les propriétés margin et padding 

Vous allez avoir besoin d'un minimum de vocabulaire en anglais ici :

  - top: haut ;

  - bottom: bas ;

  - left: gauche ;

  - right: droite.

Voyez ce que cela donne dans le schéma ci-dessous :

Vous pouvez aussi utiliser seulement les propriétés raccourcies  margin  ou padding en précisant quatre valeurs à la suite, dans le sens des aiguilles d'une montre (haut, droite, bas, gauche).

Exemple :  margin: 2px 0 3px 1px;.

Ce qui signifie :

“ 2 pixels de marge en haut, 0 pixel de marge à droite (le  px  est facultatif dans ce cas), 3 pixels de marge en bas et 1 pixel de marge à gauche”.

Centrez vos blocs avec  width  et  margin: auto;

Pour centrer des blocs, il faut respecter les règles suivantes :

  1. donner une largeur au bloc avec la propriété width ;

  2. indiquer  margin: auto; (les marges extérieures seront alors automatiques, et permettront de centrer le 
     contenu.

Essayons cette technique sur nos paragraphes, en ajoutant simplement une ligne au CSS :

p {
    width: 350px;
    background-color: #F1C864;
    text-align: justify;
    padding: 16px;
    margin: auto;
}

Et on obtient :

Il n'est cependant pas possible de centrer verticalement un bloc avec cette technique. Seul le centrage horizontal est permis.

Je vous invite maintenant à tester ce que vous venez de découvrir avec le CodePen P3C2.

À vous de jouer !

Vous allez maintenant pouvoir vous faire la main sur le site de Robbie Lens, et mettre en pratique ce que vous venez d'apprendre ! Dans la branche de départ de l'exercice, vous trouverez un bout de CSS qui indique :

* {
    margin: 0;
}

Cela sert à réinitialiser les marges par défaut des navigateurs.

À partir de là, vous allez :

- ajouter un padding au  header  et au  footer  de  20px  en haut et en bas, et de  50px  à gauche et à 
  droite ;

- ajouter une section autour du contenu de la page d'accueil ;

- ajouter une section autour du contenu de la page  A-propos  ;

- donner à vos sections (pour les futures sections à venir) un padding de  80px  ;

- créer un padding de  50px  pour  carre-contenu  ;

- centrer le contenu de la page  A-propos  ;

- aérer le contenu de la page   A-propos  : mettre de la marge au-dessus du sous-titre "Services" et de la 
  liste des compétences. 

Vous trouverez sur GitHub la base de code nécessaire pour réaliser l’exercice sur la branche P3C2-exercice. Voici la solution sur la branche P3C2-solution pour vérifier si vous aviez vu juste.

En résumé

- On distingue deux principaux types de balises en HTML :

    - les balises de type  block  comme  <p>  ou  <h1> créent un retour à la ligne et occupent par défaut 
      toute la largeur disponible. Elles se suivent de haut en bas ;

    - les balises de type  inline  comme  <a>  ou  <strong>  délimitent du texte au milieu d'une ligne. Elles 
      se suivent de gauche à droite.

- On peut modifier la taille d'une balise de type block  avec les propriétés CSS  width (largeur) et  height  
  (hauteur).

- Les éléments de la page disposent chacun de padding (marges intérieures) et de margin  (marges extérieures).

- On peut centrer le contenu d'un bloc dont la largeur est définie par width avec margin: auto;

Ça va ? Vous avez bien digéré toutes les informations ? Alors accrochez-vous ! Dans le chapitre suivant, on va voir une partie essentielle du CSS moderne : Flexbox. Alors à tout de suite !

##############################################################################################################

Faites votre mise en page avec Flexbox

Comprenez la logique : un conteneur, des éléments

Pour faire de la mise en page avec Flexbox, il faut :

  1.Définir un conteneur.

  2.Et placer à l'intérieur plusieurs éléments.

Imaginez un carton dans lequel vous rangez plusieurs objets : c'est le principe !

Sur une même page web, vous pouvez avoir plusieurs conteneurs (plusieurs cartons, si vous préférez). Vous pouvez en créer autant que nécessaire pour obtenir la mise en page que vous voulez.

Commençons par étudier le fonctionnement d'un carton (euh pardon, d'un conteneur).

Un conteneur (container en anglais) est une balise qui peut renfermer d'autres balises, comme du texte ou encore des images. Les conteneurs les plus célèbres sont les balises  <div>  et  <span> .

<div class="container">
<div class="element element1">Élément 1</div>
<div class="element element2">Élément 2</div>
<div class="element element3">Élément 3</div>
</div>

Mais si je fais ça, par défaut, mes éléments vont se mettre les uns en dessous des autres, non ? Ce sont des blocs, après tout !

Oui, tout à fait, c'est le comportement normal dont nous avons l'habitude. Découvrons donc maintenant l'intérêt de Flexbox !

Alignez les éléments d'un conteneur avec  display: flex; 

Il suffit d'une seule propriété CSS, et tout change ! Cette propriété, c'est flex  et on l'applique au conteneur :

.container {
    display: flex;
}

... alors les blocs se placent par défaut côte à côte. Magique !

Donnez leur une direction avec la propriété  flex-direction

Flexbox permet d'agencer ces éléments dans le sens que l'on veut. Avec flex-direction, on peut les positionner verticalement ou encore les inverser. Cette propriété CSS peut prendre les valeurs suivantes :

  - row  : organisés sur une ligne (par défaut) ;

  - column  : organisés sur une colonne ;

  - row-reverse  : organisés sur une ligne, mais en ordre inversé ;

  - column-reverse  : organisés sur une colonne, mais en ordre inversé.

Ici, on fait simplement :

.container {
    display: flex;
    flex-direction: column;
}

Ce qui donne :

Mais mais... c'est pareil qu'au début, non ? On avait ce résultat sans Flexbox, après tout !

C'est vrai. Mais maintenant que nos éléments sont flex, ils ont tout un tas d'autres propriétés utiles que nous allons voir juste après, on va y revenir.

Essayez aussi de tester l'ordre inversé, pour voir :

.container {
    display: flex;
    flex-direction: column-reverse;
}

Et voilà ce que ça donne :

Regardez bien la différence : les blocs sont maintenant dans l'ordre inverse ! Je n'ai pas du tout changé le code HTML, qui reste le même depuis le début.

Retournez à la ligne avec la propriété  flex-wrap

Par défaut, les blocs essaient de rester sur la même ligne s'ils n'ont pas la place, quitte à "s'écraser",  et provoquer parfois des anomalies dans la mise en page (certains éléments pouvant dépasser de leur conteneur). Si vous voulez, vous pouvez demander à ce que les blocs aillent à la ligne lorsqu'ils n'ont plus la place, avec flex-wrap.

Voilà les différentes valeurs de flex-wrap :

nowrap  : pas de retour à la ligne (par défaut) ;

wrap  : les éléments vont à la ligne lorsqu'il n'y a plus la place ;

wrap-reverse  : les éléments vont à la ligne, lorsqu'il n'y a plus la place, en sens inverse.

.container {
    display: flex;
    flex-wrap: nowrap; 
    /* OU wrap;
    OU wrap-reverse; */
}

Dans les illustrations suivantes, vous pouvez voir les différents comportements de nos blocs en fonction de la valeur que l'on attribue à  flex-wrap  : 

Cette propriété sera particulièrement utile quand nous aurons besoin d'adapter nos pages aux plus petits écrans. Nous verrons ça dans la prochaine partie de ce cours.

Alignez les éléments sur un axe principal et secondaire

Les éléments sont organisés par défaut de manière horizontale. Mais ils peuvent être organisés de manière verticale. Selon le choix que vous faîtes, ça va définir ce qu'on appelle l'axe principal. Il y a aussi un axe secondaire :

  - si vos éléments sont organisés horizontalement, l'axe secondaire est l'axe vertical ;

  - si vos éléments sont organisés verticalement, l'axe secondaire est l'axe horizontal.

Pourquoi je vous raconte ça ? Parce que nous allons découvrir comment aligner nos éléments sur l'axe principal et sur l'axe secondaire.

Alignez sur l'axe principal avec la propriété  justify-content

Pour faire simple, partons sur des éléments organisés horizontalement (c'est le cas par défaut).

Pour changer leur alignement, on va utiliser justify-content, qui peut prendre ces valeurs :

  - flex-start: alignés au début (par défaut) ;

  - flex-end: alignés à la fin ;

  - center: alignés au centre ;

  - space-between: les éléments sont étirés sur tout l'axe (il y a de l'espace entre eux) ;

  - space-around: idem, les éléments sont étirés sur tout l'axe, mais ils laissent aussi de l'espace sur les 
    extrémités.

On écrit alors :

.container {
    display: flex;
    justify-content: flex-start /* OU flex-end
    OU center
    OU space-between
    OU space-around; */
}

Le mieux est encore de tester toutes les valeurs possibles pour voir ce que ça donne, vous ne pensez pas ?

Manipulez toutes les valeurs possibles de  justify-content  dans le CodePen P3C3.

Vous voyez comment les éléments s'alignent différemment selon les cas ? Avec une simple propriété, on peut intelligemment agencer nos éléments comme on veut !

Maintenant, voici ce qu'il faut bien comprendre : ça marche aussi si vos éléments sont dans une direction verticale. Dans ce cas, l'axe vertical devient l'axe principal, et justify-content s'applique aussi :

.container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    height: 350px; /* Un peu de hauteur pour que les éléments aient la place de bouger */
}

Avec une direction verticale (“column”), le centrage fonctionne de la même façon, mais cette fois en hauteur.

Ajoutez  flex-direction: column;  dans le CodePen P3C3, vous verrez la différence !

Alignez sur l'axe secondaire avec  align-items
Si nos éléments sont placés dans une direction horizontale (ligne), l'axe secondaire est... vertical. Et inversement : si nos éléments sont dans une direction verticale (colonne), l'axe secondaire est horizontal.

La propriété align-items  permet de changer leur alignement sur l'axe secondaire, grâce aux valeurs :

  - stretch: les éléments sont étirés sur tout l'axe (valeur par défaut) ;

  - flex-start: alignés au début ;

  - flex-end: alignés à la fin ;

  - center: alignés au centre ;

  - baseline: alignés sur la ligne de base (semblable à  flex-start  ).

Pour ces exemples, nous allons partir du principe que nos éléments sont dans une direction horizontale (mais n'hésitez pas à tester aussi dans la direction verticale !).

.container {
    display: flex;
    justify-content: center;
    align-items: center;
}

Ajoutez align-items: center;  dans le CodePen P3C3, vous verrez le résultat !

Saint Graal du développeur web, le centrage vertical et horizontal peut d'ailleurs être obtenu encore plus facilement. Dites-vous que votre conteneur est une Flexbox, et établissez des marges automatiques sur les éléments à l'intérieur. C'est tout ! Essayez :

.container {
    display: flex;
}

.element {
    margin: auto;
}

Répartissez les blocs sur plusieurs lignes avec align-content

Si vous avez plusieurs lignes dans votre Flexbox, vous pouvez choisir comment celles-ci seront réparties avec align-content.

Cette propriété n'a aucun effet s'il n'y a qu'une seule ligne dans la Flexbox.

Prenons donc un cas de figure où nous avons plusieurs lignes. J'autorise les éléments à aller à la ligne avecflex-wrap.

Voyons voir comment les lignes se répartissent différemment avec la nouvelle propriété align-content  que je voulais vous présenter. Elle peut prendre ces valeurs :

  - stretch  (par défaut) : les éléments s'étirent pour occuper tout l'espace ;

  - flex-start  : les éléments sont placés au début ;

  - flex-end  : les éléments sont placés à la fin ;

  - center  : les éléments sont placés au centre ;

  - space-between  : les éléments sont séparés avec de l'espace entre eux ;

  - space-around  : idem, mais il y a aussi de l'espace au début et à la fin.

Amusez-vous avec le CodePen P3C3 pour tester tout cela en remplaçant la propriété  justify-content  par  align-content  !

Et si vous voulez vous entraîner pour vous assurer que vous maîtrisez bien les propriétés de Flexbox, je vous recommande le jeu Flexbox Froggy. Avec les différentes propriétés, vous devrez replacer les grenouilles sur les nénuphars. 

À vous de jouer !

Maintenant que vous maîtrisez les propriétés de Flexbox, nous allons en profiter pour mettre en forme les pages du portfolio de Robbie Lens !

À partir de maintenant, la mise en page devient plus élaborée : vous pouvez donc, si vous le voulez, vous référer à la maquette (le modèle) du site de Robbie Lens.

Pour y accéder, vous avez besoin de créer un compte sur Figma, c'est gratuit.

Des modifications ont été apportées au fichier de code pour que vous ayez davantage d'éléments :

- des images ont été ajoutées dans le dossier "images" ;

- des sections ont été ajoutées dans la page d'accueil ;

- le style du footer a été modifié pour avoir le logo en haut à gauche de la page, et les liens de navigation 
  à droite.

Allez récupérer le modèle que vous trouverez dans la branche P3C3-exercice.

À partir de cette base de code, vous allez :

- utiliser  flex  pour avoir le logo en haut à gauche de la page, et les liens de navigation à droite dans 
  l’en-tête ;

- réagencer les éléments pour avoir le titre de la page d'accueil, le paragraphe, et le lien ayant la classe 
  "CTA" à gauche, et la photo à droite ;

- importer les images dans la page d'accueil, et créer une grille d'images avec deux rangées de 3 images 
  chacune. 

Vous trouverez dans la base de code, pour démarrer l'exercice, des exercices qui vous aideront à mettre en place votre code. Et une fois que vous aurez fini, vous pouvez comparer ce que vous avez fait avec la solution sur la branche P3C3-solution.

En résumé

- Le principe de Flexbox est d'avoir un conteneur avec plusieurs éléments à l'intérieur. Avec  display: flex;  
  sur le conteneur, les éléments à l'intérieur sont agencés en mode Flexbox (horizontalement, par défaut).

- Flexbox peut gérer toutes les directions. Avec  flex-direction , on peut indiquer si les éléments sont 
  agencés horizontalement (par défaut) ou verticalement. Cela définit ce qu'on appelle l'axe principal.

- L'alignement des éléments se fait sur l'axe principal avec  justify-content  et sur l'axe secondaire avec  
  align-items .

- Avec  flex-wrap, on peut autoriser les éléments à revenir à la ligne s'ils n'ont plus d'espace.

- S'il y a plusieurs lignes, on peut indiquer comment les lignes doivent se répartir entre elles avec  align-
  content.

Alors, la découverte de Flexbox vous a plu ? J'espère, parce que dans le chapitre suivant nous allons voir les bases d'un outil tout aussi puissant : CSS Grids !

##############################################################################################################

Découvrez les bases de CSS Grids

Définissez une grid avec la propriété CSS display: grid;

De la même manière que pour Flexbox, lorsque vous utilisez CSS Grids, vous pouvez imaginer un conteneur, une sorte de "carton" dans lequel vous allez mettre les éléments de votre grid. Sauf que, cette fois-ci, vous allez avoir besoin de déclarer la propriété display: grid; :

.conteneur {
    display: grid;
}

Ensuite, il faut préciser quelques éléments supplémentaires si on veut que ça fonctionne. Pour ce faire, il s'agit de se demander comment représenter nos éléments. Lorsque vous créez un tableau, vous réfléchissez aux colonnes et aux rangées qu'il faudra créer. Eh bien, c'est la même chose ici !

On va définir les colonnes et les rangées avec deux propriétés :

  1. grid-template-columns pour le nombre de colonnes, et la largeur de chacune d'entre elles.

  2. grid-template-rows pour le nombre de rangées, et la hauteur de chacune d'entre elles.

Définissez vos colonnes avec la propriété CSS  grid-template-columns
On a déjà 9 éléments déclarés côté HTML de la manière suivante :

<div class="conteneur">
    <div class="box">🐸 Élément 1</div>
    <div class="box">🦊 Élément 2</div>
    <div class="box">🦄 Élément 3</div>
    <div class="box">🐶 Élément 4</div>
    <div class="box">🐨 Élément 5</div>
    <div class="box">🐒 Élément 6</div>
    <div class="box">🦆 Élément 7</div>
    <div class="box">🐙 Élément 8</div>
    <div class="box">🐋 Élément 9</div>
</div>

La classe CSS .box permet d'ajouter un peu de style aux éléments. Pour que le contenu plus harmonieux, on va donner à chaque élément une hauteur de  150px :

.box {
  height: 150px;
}

Plus bas, dans le fichier CSS, créons 3 colonnes, chacune de  200px  de large, à l'aide de la propriété grid-template-columns:

.conteneur {
    display: grid;
    grid-template-columns: 200px 200px 200px;
}

Et on obtient :

Magique, n'est-ce pas ?

On n'a même pas eu à dire "je veux 3 colonnes" : le nombre de colonnes a tout simplement été déduit par le navigateur, à partir du moment où on a spécifié 3 largeurs distinctes Si vous définissez 10 largeurs, vous aurez 10 colonnes.

Et vous pouvez moduler la largeur que vous souhaitez pour chacune de vos colonnes. Par exemple, on pourrait écrire :

.conteneur {
    display: grid;
    grid-template-columns: 100px 300px 200px;
}

Et on obtient alors :

Définissez vos rangées avec la propriété CSS grid-template-rows

Passons maintenant à la propriété grid-template-rows. Et on fait bien attention à supprimer la hauteur fixe qu'on avait associée à la classe  .box :  height: 150px;  .

Pourquoi il faut faire ça ? Je ne comprends pas.

En fait, indiquer une hauteur avec la propriété  height  à  .box  a pour effet d'assigner une hauteur fixe pour tous les éléments de classe  .box  . Or, on peut avoir besoin de définir des hauteurs différentes aux rangées, ce qu'on va pouvoir spécifier avec  grid-template-rows  , en indiquant la hauteur de chacune, comme on l'a fait pour  grid-template-columns  :

.conteneur {
    display: grid;
    grid-template-columns: 200px 200px 200px;
    grid-template-rows: 100px 150px 200px;
}

Si vous laissez la hauteur fixe et que vous indiquez en même temps différentes hauteurs pour les rangées :

.box {
  height: 150px;
}

.conteneur {
    display: grid;
    grid-template-columns: 200px 200px 200px;
    grid-template-rows: 100px 150px 200px;
}

…ça ne marche pas, en tout cas, le navigateur va vouloir appliquer les deux instructions en même temps ce qui ne vous donnera pas l'effet voulu et les éléments vont se chevaucher :

Sans hauteur fixe et grâce aux hauteurs spécifiées une à une, on a donc bien 3 rangées, une de 100px  de hauteur, la seconde de  150px  , et la troisième de  200px . Voyez par vous-même :

Pas mal, n'est-ce pas ?

C'est un peu écrasé tout ça. Il faut que j'ajoute des marges ou paddings sur chaque élément pour faire respirer mon contenu ?

Aérez votre contenu avec la propriété CSS  gap

La propriété CSS gap permet de créer des espacements entre vos éléments. Si vous voulez garder les mêmes distances entre les rangées et les colonnes sans avoir à vous compliquer la vie, vous précisez simplement une valeur.

On écrit alors :

.conteneur {
    display: grid;
    grid-template-columns: 200px 200px 200px;
    grid-template-rows: 100px 150px 200px;
    gap: 10px;
}

Et on obtient :

Choisissez vos unités

Jusqu'à maintenant, nous avons utilisé une unité en px pour définir les hauteurs et largeurs des rangées et colonnes. Mais il est également possible d'utiliser des em, rem, et des pourcentages.

Et encore mieux : je vais vous montrer une unité qui est spécifique aux grids : les "fraction units", ou fr pour les intimes, qui représentent des parts de largeur dans les colonnes.

Mais pourquoi utiliser les  fr  alors qu'on a des pourcentages ?

Si vous tentez d'utiliser des pourcentages avec CSS Grid, vous verrez que ce n'est pas toujours simple. Si par exemple, vous souhaitez créer 2 colonnes dans une  grid  , et que vous mettez  50%  de largeur pour chacune d'entre elles, vous vous attendez sûrement à ce que votre grid prenne toute la largeur… Et pourtant non : les grid gaps (les espacements entre vos grids) peuvent venir mettre le bazar dans tout ça, et votre grid va dépasser. C'est pourquoi il est encore plus simple d'utiliser des fr , l'unité créée spécialement pour les CSS Grids.

Donc si dans notre code on a :

.conteneur {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 50px 100px 200px;
    gap: 10px;
}

… on aura :

… et vous pouvez ajuster la taille en fonction de la colonne. Par exemple :

.conteneur {
    display: grid;
    grid-template-columns: 1fr 2fr 1fr;
    grid-template-rows: 50px 100px 200px;
    grid-gap: 10px;
}

… nous donne :

Le code utilisé pour réaliser cette grille est disponible dans le CodePen P3C4a.

Définissez la taille des éléments de votre  grid

Pour l'instant, nos grilles sont assez sages, et nous n'avons rien fait que nous ne pourrions faire avec Flexbox. Mais je vais vous montrer comment secouer tout ça !

Si vous vouliez obtenir ce résultat, par exemple ?

Pour cela, vous allez apprendre à maîtriser les propriétés liées à grid-column  et grid-row.

C'est surtout dans ce genre de cas qu'on voit que CSS Grid est complémentaire à Flexbox. Créer ce type de mise en page serait vraiment plus laborieux avec Flexbox, alors qu'ici, on peut le faire assez simplement.

À chaque fois que vous écrivez display: grid, le navigateur se représente votre conteneur comme un ensemble d'éléments délimités par des lignes horizontales et verticales. Ces lignes sont invisibles, mais peuvent être inspectées avec les outils de développement.

Dans notre cas, pour réaliser une grid similaire à ce que je vous montrais, avec des éléments à cheval sur plusieurs colonnes ou plusieurs rangées, on va devoir indiquer un point de départ et un point d'arrivée pour nos éléments.

On aura besoin des propriétés suivantes pour déclarer nos éléments :

  - grid-column-start indique la ligne verticale de départ de l'élément ;

  - grid-column-end indique la ligne verticale d'arrivée de l'élément ;

  - grid-row-start indique la ligne horizontale de départ de l'élément ;

  - grid-row-end indique la ligne horizontale d'arrivée de l'élément.

Ainsi, on change un peu notre code pour avoir une structure qui nous permet simplement de mettre en place la grid. Ce qui nous donne en HTML :

<div class="conteneur">
    <div class="box une">🐸 Élément 1</div>
    <div class="box deux">🦊 Élément 2</div>
    <div class="box trois">🦄 Élément 3</div>
    <div class="box quatre">🐶 Élément 4</div>
    <div class="box cinq">🐨 Élément 5</div>
    <div class="box six">🐒 Élément 6</div>
    <div class="box sept">🦆 Élément 7</div>
    <div class="box huit">🐙 Élément 8</div>
    <div class="box neuf">🐋 Élément 9</div>
</div>

Et en CSS, on a :

.conteneur {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 100px 100px 100px 100px 100px;
    grid-gap: 10px;
}

Mesurez vos colonnes

Prenons notre première  div  :  .une.

Si on veut qu'elle prenne toute la largeur, comme dans le résultat attendu, on doit alors préciser :

.une {
    grid-column-start: 1;
    grid-column-end: 4;
}

Et vous pouvez même l'écrire en une seule ligne avec la propriété raccourcie  grid-column  :

.une {
    grid-column: 1 / 4;
}

Attendez, mais pourquoi on dit d'aller jusqu'à  4  pour prendre toute la largeur, alors qu'il n'y a que 3 colonnes ? On ne devrait pas plutôt dire  grid-column-end: 3;  pour dire qu'elle s'arrête à la troisième colonne ?

Et non car ça reviendrait à dire qu'elle s'arrête juste avant le dernier tiers, donc juste avant la troisième colonne. C'est déroutant je vous l'accorde mais en fait on compte +1 avec cette technique. Le navigateur considère que pour couvrir toute la largeur, on "atteint" un élément suivant.

Mesurez vos rangées
On veut maintenant créer le deuxième élément de la grid, qui s'étale sur deux rangées en hauteur, à partir de la deuxième rangée (l'élément  .une  occupe déjà la première rangée). On précise donc que  .deux  commence à la rangée 2 et finit sur la rangée 4 :

.deux {
    grid-row-start: 2;
    grid-row-end: 4;
}

Ce qui équivaut à :

.deux {
    grid-row: 2 / 4;
}

En allant jusqu'au bout de notre logique, on obtient bien :

ous pouvez retrouver le code complet de la  grid  dans le CodePen P3C4b.

Si vous avez l'impression de vous embrouiller entre les différentes propriétés de CSS Grid, pas de panique. CSS Grid est relativement avancé en CSS. L'idée de ce chapitre est de vous montrer le champ des possibles avec les grids.

Si vous voulez aller plus loin, vous pouvez :

  - creuser la documentation de la mise en page à l'aide des CSS Grids ;

  - suivre le cours Create Web Page Layouts with CSS (il n’existe pas en version française sur la plateforme 
    pour l’instant) ;

  - vous faire la main sur le petit jeu Grid Garden 
    (en anglais, lien : https://codepip.com/games/grid-garden/#fr) (vous pouvez créer un compte gratuitement 
    sur Codepip).

Nous avons vu quelques-unes des propriétés les plus utiles des CSS Grids, mais il y en a bien d'autres. Des raccourcis qui vous simplifient encore plus la vie, des syntaxes particulièrement claires. Donc n'hésitez pas à jeter un œil à tout cela un peu plus tard dans votre apprentissage du CSS.

À vous de jouer !

Vous allez maintenant pouvoir tirer parti des grids pour le portfolio de Robbie Lens ! Comme d’habitude, retrouvez sur GitHub la base de code nécessaire pour faire l’exercice sur la branche P3C4-exercice. 

Vous trouverez une nouvelle page portfolio. La base de la page a déjà été codée, et ajoutée dans le header. De nouvelles images ont également été importées dans  images/portfolio  .

À partir de là, vous devrez coder deux grids :

  1. une première grid avec les images dont le nom commence par "paysage". Elle comprend 3 colonnes et 3 
     rangées ;

  2. une deuxième grid de 3 colonnes et 2 rangées, avec les images dont le nom commence par "portrait".

Les colonnes devront s'adapter à la largeur de l'écran, et les rangées feront  300px  de haut, avec un écart de  15px.

Même si nous ne verrons pas ces propriétés dans ce cours, vous aurez besoin du bout de code dans les sélecteurs  .grid-paysages img  et  .grid-portraits img  afin que la taille de vos images s'adaptent à la taille de votre grid.

Les images des deux grids font la même taille.

Vous êtes aussi libre de vous exercer sur des formats plus élaborés qui ressemblent aux exemples vus dans le chapitre.

Comme d'habitude, vous pouvez consulter la solution sur la branche P3C4-solution.

En résumé

- Les CSS Grids sont complémentaires à Flexbox et permettent de créer facilement des mises en page plus 
  élaborées que Flexbox, sans forcément avoir des éléments de la même taille.

- Pour déclarer une grid, on déclare simplement  display: grid;  sur le conteneur : notre navigateur comprend 
  tout de suite que nos éléments sont dans la grid.

- On définit les colonnes avec grid-template-columns  et les rangées avec grid-template-rows : en fonction du 
  nombre de valeurs passées, de nouvelles colonnes et rangées sont créées.

- En plus des unités classiques  px  ,  em  ,  rem  et  %  , les  fr  sont encore plus simples, et permettent 
  d'indiquer une fraction de la grille.

- gap  permet d'espacer les éléments entre eux.

- Les grids créent implicitement des lignes horizontales et verticales délimitant les différentes rangées et 
  colonnes.

- Chaque élément peut avoir :

    - son propre point de départ horizontal avec  grid-row-start  ;

    - son point d'arrivée horizontal avec  grid-row-end  ;

    - son point de départ vertical avec  grid-column-start  ;

    - et son point d'arrivée vertical avec  grid-column-end  .

Et voilà, c'est tout pour le moment sur les grids. Vous commencez à disposer de pas mal d'outils de mise en page CSS. C'est normal si cela vous ne paraît pas encore très clair pour l'instant, mais vous verrez : avec la pratique, ça finit par rentrer ! En attendant, on se retrouve dans le dernier chapitre de la partie, qui nous permettra d'aborder d'autres techniques de mise en page en CSS. Alors à tout de suite !

##############################################################################################################

Abordez d'autres techniques de mise en page

Transformez vos éléments avec  display

La propriété CSS display permet de transformer n'importe quel élément de votre page, d'un type vers un autre. Avec cette propriété, on peut par exemple imposer à des liens (originellement de type  inline  ) d'apparaître sous forme de type  block  :

a {
    display: block;
}

À ce moment-là, les liens vont se positionner les uns en dessous des autres (comme des blocs normaux), et il devient possible de modifier leurs dimensions ! Et à l'inverse, vous pouvez tenter de faire en sorte qu'un élément qui est de type  block  par défaut devienne  inline .

Si vous ne vous souvenez plus de la différence entre  inline  et  block  , je vous conseille de relire le chapitre “Découvrez le modèle des boîtes”.

Cachez vos éléments avec  display: none;

On peut également décider de masquer complètement un élément de la page en attribuant à display la valeur none. Par exemple, si je veux masquer les éléments qui ont la classe secret, je vais écrire :

.secret {
    display: none;
}

none est très pratique lorsqu'il faut cacher certains éléments en fonction de la taille de l'écran.

Pour tester cela, essayez de réduire la taille de la fenêtre du CodePen P3C5a !

La liste des différentes valeurs possibles pour  display  est longue. Nous n'aurons pas le temps de toutes les aborder ensemble ici, mais sachez qu'il est notamment possible de tirer parti du meilleur de  inline  et  block  . Pour cela, vous pouvez utiliser  display: inline-block;  qui rend vos éléments  inline  tout en permettant de les dimensionner.

Positionnez vos éléments avec la propriété CSS  position

Dans les méthodes que nous avons vues jusqu'à maintenant, le navigateur dispose les éléments afin qu'ils ne se superposent jamais. Ils font partie d'un flux normal. Mais nous allons maintenant voir une nouvelle propriété :position. Elle permet de positionner avec précision des éléments sur la page (et même parfois de les superposer).

  - Le positionnement relatif permet de décaler l'élément par rapport à sa position normale.

  - Le positionnement absolu permet de placer un élément n'importe où sur la page (en haut à gauche, en bas à 
    droite, tout au centre, etc.).

  - D'autres types de positionnements comme fixed ou encore sticky, qui ont des comportements assez 
    semblables, peuvent être utiles si l'on veut qu'un élément, tel que le menu de navigation par exemple, 
    reste à l'écran.

Le positionnement fonctionne aussi bien sur des balises qui sont  inline  que   block  . Mais dans les faits, vous verrez qu'on l'utilise bien plus souvent sur des balises  block  que sur des balises  inline  .

Il faut d'abord faire son choix entre les trois modes de positionnement disponibles. Pour cela, on utilise la propriété CSS position.

Regardons tout ça d'un peu plus près !

Définissez un positionnement relatif avec  position: relative;
Le positionnement relatif permet d'effectuer des ajustements : l'élément est décalé par rapport à sa position initiale.

Prenons par exemple un texte dans lequel se trouve un lien. Pour commencer, on donne une couleur de fond au body, et on met le lien sur un fond blanc.

Ici, on utilise position: relative;. Notre élément a alors un point d'origine : le point de coordonnées  (0, 0)  qui va nous permettre de le déplacer : 

On accède alors à quatre propriétés CSS qui vont nous permettre de décaler notre élément :

left   : décalage depuis la gauche.

right  : décalage depuis la droite.

top  : décalage depuis le haut de notre élément.

bottom   : décalage depuis le bas de notre élément.

Ainsi, si j'écris le CSS suivant :

a {
    background-color: white;
    position: relative;
    top: 6px;
    left: 10px;
}

Regardez ce que ça donne :

Définissez un positionnement absolu avec  position: absolute;
Le positionnement absolu permet de placer un élément (réellement) n'importe où sur la page. Pour l'utiliser, on écrit tout simplement position: absolute;:

a {
    background-color: white;
    position: absolute;
    top: 6px;
    left: 10px;
}

Manipulez les deux positionnements et jouez avec les décalages grâce au CodePen P3C5b !

Prenons un autre exemple maintenant, et regardez le résultat du CodePen P3C5c.

Bon c'est bien beau, mais cela ne suffit pas pour positionner un élément où on souhaite vraiment. Pour y parvenir, on va refaire appel à nos  left,  right,  top  et  bottom.

On pourra leur donner une valeur en pixels, comme 14px ou une valeur en pourcentage, comme 50%  .

Habituellement, les éléments  inline  et  block  sont disposés dans le flux normal. Mais ici, vous voyez, nos éléments ne respectent plus rien, et sortent du flux.

Donc quand j'utilise  left  ,  right  ,  top  et  bottom, mon élément va toujours se placer par rapport aux bords de la page ?

Eh bien… pas nécessairement. Un élément  absolute  va se positionner par rapport au premier élément qu'il rencontre dans ses parents, et qui utilise lui-même la propriété  position . Donc si on veut placer un élément par-dessus un autre, il faudra que ce premier élément utilise aussi la propriété  position.

Regardez un peu ce que cela donne :

La propriété position unset réinitialise la propriété afin que sa valeur soit la valeur héritée depuis l'élément parent, ou soit la valeur initiale (s'il n'y a pas d'héritage).

Dans le CodePen P3C5d, on a utilisé les positions absolues.

Gérez le chevauchement avec la propriété  z-index

Vous l'avez remarqué, les éléments positionnés en absolu sont placés par-dessus le reste des éléments de la page. Mais si vous placez deux éléments en absolu aux mêmes coordonnées… ils vont se chevaucher.

Dans ce cas, vous pouvez utiliser la propriété z-index  pour indiquer quel élément doit apparaître au-dessus des autres : vous empilez vos éléments dans l'ordre souhaité ! L'élément ayant la valeur de  z-index  la plus élevée sera placé par-dessus les autres.

Si j'écris le HTML :

<div class="conteneur">
    <div class="box une">Élément 1</div>
    <div class="box deux">Élément 2</div>
    <div class="box trois">Élément 3</div>
<div>

…associé au CSS suivant :

.conteneur {
    position: relative;
    height: 300px;
    width: 300px;
}

.une {
    background-color: #C2B0F9;
    position: absolute;
    left: 0;
    top: 90px;
}

.deux {
    background-color: #CBFCB9;
    position: absolute;
    right: 70px;
    top: 0;
}

.trois {
    background-color: #F2A3BB;
    position: absolute;
    right: 0;
    bottom: 20px;
}

…on obtient :

Mais en chamboulant les  z-index, regardez ce que ça peut donner avec le CodePen P3C5e.

Bloquez un élément avec fixed ou sticky

Le principe est exactement le même que pour le positionnement absolu sauf que, cette fois, le bloc se fige, même si on descend plus bas dans la page. Pour faire cela, il y a deux options possibles : attribuer la valeur  fixed  ou  sticky  à la propriété CSS  position  .

Rendez un élément fixe avec  position: fixed;
En HTML, on écrit :

<div class="box fixed">Élément fixed</div>

et en CSS, on écrit :

element {
    position: fixed;
    right: 0;
    top: 0;
}

Vous voyez, avec la valeur  fixed  , l'élément fixe ne bouge pas.

Rendez un élément adhérent avec  position: sticky;
avec  <div class="box sticky">Élément sticky</div>

element {
    position: sticky;
    top: 0;
}

Et c'est la même chose pour la valeur sticky: l'élément ne bouge pas

Attendez mais  fixed  et  sticky  exactement le même résultat ? Je ne comprends pas la différence entre un élément fixe et un élément adhérent… Qu'est-ce que ça change ?

Vous allez voir tout de suite la différence dans le CodePen P3C5f lorsque vous essaierez de scroller pour descendre plus bas sur la page !

À vous de jouer !

Vous allez maintenant pouvoir exploiter ce que vous venez d'apprendre dans le portfolio de Robbie Lens. Les images de la page "Portfolio" peuvent maintenant s'afficher en plein écran avec la méthode vue dans le chapitre “Insérez des images”. Pour cela, des liens ont été ajoutés avec la classe  lien-conteneur-photo  .

Vous pouvez retrouver sur GitHub la base de code pour faire l’exercice sur la branche P3C5-exercice. 

Pour ce chapitre, vous allez :

 - transformer les liens qui ont la classe  .cta  en éléments  inline-block  avec  display  sur les pages 
   "Accueil" et "À propos", et ajouter leur lien vers la page "Portfolio" ; (cta veut dire call to action en 
   anglais, autrement dit, en français : "bouton d'appel à l'action") ;

 - ajouter des  margin  et  padding  là où il en manque sur les pages "Accueil" et "À propos" (pour rappel, 
   voici la maquette d’inspiration pour le site) ;

 - créer sur les images un effet au survol de la souris en affichant un élément (grâce à display ) qui :

         - aura un fond noir d’une opacité de  70%  ;

         - s’affichera par-dessus l’image, et y mentionnera le texte suivant : “Voir la photo”, comme ceci :

Et voici la solution de l'exercice sur la branche P3C5-solution.

En résumé

- La propriété  display  permet de changer le comportement de base d'un élément : 

        - transformer un élément  inline  en  block  ;

        - inversement, un élément  block  en  inline  ;

        - mais aussi de faire un mélange des deux avec  inline-block.

- Le positionnement relatif permet de décaler un bloc par rapport à sa position normale.

- Le positionnement absolu permet de placer un élément où l'on souhaite sur la page, au pixel près.

- Un élément A positionné en absolu à l'intérieur d'un autre élément B (lui-même positionné en absolu, fixe ou 
  relatif) se positionne par rapport à l'élément B, et non par rapport au coin en haut à gauche de la page.

- Lorsque plusieurs éléments s'empilent, il est possible de les ordonner avec  z-index.

##############################################################################################################

