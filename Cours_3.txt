Structurez votre page

Utilisez la balise  <header> pour l'en-tête

La plupart des sites web possèdent un <header>(en-tête, en français). On y trouve le plus souvent, à minima, un logo. On le place, pour des raisons de cohérence, en tête du code, donc au début de la balise   <body>  :

<header>
<!-- Placez ici le contenu de l'en-tête de votre page -->
</header>

L'en-tête peut contenir tout ce que vous voulez : une image pour un logo, liens, du texte pour le slogan de votre marque par exemple, un bouton d'appel à l'action… Généralement, on préfère que cela reste clair et lisible donc on évite de surcharger le  <header>  avec trop d'éléments.

Voici par exemple l’en-tête du site de La Fourche :

Attention, la balise <header>  n'a rien  à voir avec la balise  <head>  que vous aviez vue dans la première partie :

  - la balise <header>  permet de créer une partie de la page HTML ;

  - la balise  <head>  permet d'inclure des informations générales sur la page, notamment son titre, des liens 
    vers des polices, vers une feuille de style, etc.

Il peut y avoir plusieurs en-têtes dans votre page. Si celle-ci est découpée en plusieurs sections, chaque section peut en effet avoir son propre  <header>  .

Utilisez la balise  <footer>  pour le pied de page

À l'inverse de l'en-tête, le pied de page se trouve tout en bas de la page. On y trouve généralement des informations comme des liens de contact, les mentions légales, la politique de confidentialité, etc.

<footer>
<!-- Placez ici le contenu du pied de page -->
</footer>
Voici le pied de page de la page d’accueil du site de La Fourche :

Utilisez la balise  <nav> pour le menu de navigation

La balise <nav>  doit regrouper tous les principaux liens de navigation du site. Vous y placerez par exemple le menu principal de votre site. Généralement, le menu est réalisé sous forme de liste à l'intérieur de la balise<nav> .

Voici le menu sur le site de La Fourche :

Ici on pourrait avoir, de façon simplifiée :

<nav>
    <ul>
        <li>
            <a href="#">Nouveautés</a>
        </li>
        <li>
            <a href="#">Anti-gaspi</a>
        </li>
        <li>
            <a href="#">Origine France</a>
        </li>
        <li>
            <a href="#">Marque La Fourche</a>
        </li>
    </ul>
</nav>

Utilisez la balise  <main>  pour le contenu principal de la page

La balise <main> permet de déclarer le contenu principal de votre page. Elle englobe la majeure partie du  <body>  d'une page, en excluant les autres éléments tels que le  <header>, le  <footer>  et de potentiels  <aside>. La balise <main> doit être unique : il n'y en a qu'une seule par page :

<main>
</main>

Utilisez des balises  <section>  pour structurer le contenu du  <main>

La balise <section>  sert à regrouper des contenus en fonction de leur thématique. Elle englobe généralement une portion du contenu au centre de la page.

<section>
</section>

Sur la page d'accueil du site de La Fourche, on trouve plusieurs blocs qui pourraient être considérés comme des sections de page :

Utilisez une balise  <aside>  pour des contenus additionnels dans le  main
Il existe d'autres balises pour structurer une page, comme <aside> par exemple, qui permet de contenir des informations complémentaires au document que l'on visualise. Ces informations sont généralement placées sur le côté (bien que ce ne soit pas une obligation). Il peut y avoir plusieurs blocs <aside>  dans la page. Sur Wikipédia, par exemple, il est courant de voir à droite un bloc d'informations complémentaires à l'article que l'on visualise.

À noter : la balise <article>  sert à englober une portion généralement autonome de la page. C'est une partie de la page qui pourrait ainsi être reprise sur un autre site. C'est le cas par exemple des actualités (articles de journaux ou de blogs).

Ne vous y trompez pas : ce schéma propose un exemple d'organisation de la page. Rien ne vous empêche de décider que votre menu de navigation soit à droite, ou tout en haut, que vos balises  <aside>  soient au-dessus, etc.

Essayez d'utiliser toutes les balises que nous venons de découvrir avec le CodePen P3C1.

Ce code peut vous aider à comprendre comment les balises doivent être agencées. Vous y reconnaissez un en-tête, un menu de navigation, un pied de page… et, au centre, deux sections incluses dans  <main>  .

Eh mais… la page ne ressemble à rien, c'est normal ?

Pour l'instant, vous avez juste du texte noir sur fond blanc. C'est normal, il n'y a pas de CSS ! Par contre, la page est bien structurée, ce qui va nous être utile pour la suite. Vous pouvez d'ailleurs totalement appliquer le style souhaité à ces balises, comme vous le feriez pour toutes les balises que vous avez utilisées jusqu'à maintenant.

Je ne comprends pas l'intérêt de ces balises. On peut obtenir le même résultat sans les utiliser, non ?

C'est vrai. En fait, ces balises sont seulement là pour expliquer à l'ordinateur :

“Ceci est l'en-tête”.

“Ceci est mon pied de page”, etc.

Mais qui dit que l'ordinateur comprend veut aussi dire que le contenu sera également plus lisible par des outils d'assistance dans le cadre de l'accessibilité.

Elles n'indiquent pas, contrairement à ce qu'on pourrait penser, où doit être placé le contenu. C'est le rôle du CSS, comme nous le verrons dans peu de temps maintenant.

À l'intérieur de ces balises structurantes, comme vous l'avez sûrement vu dans le bout de code embarqué, vous pouvez également utiliser des balises universelles  <div>  et  <span>  afin de créer des blocs au sein de votre contenu, qui vous permettront ensuite de leur appliquer du style.

À vous de jouer !

C'est le moment de mettre en pratique ce que vous venez d'apprendre dans le portfolio de Robbie Lens. Pour cela, vous allez :

- intégrer un  <header>  dans les pages d'accueil et Á propos ;

- intégrer un  <footer>  dans ces même pages ;

- ajouter  <main>  là où c'est nécessaire ;

- basculer vos liens hypertextes de navigation dans une balise  <nav>  ;

- adapter les déclarations CSS en fonction des modifications faites. 

Comme d'habitude, vous avez accès sur GitHub à la base de code pour faire l’exercice sur la branche P3C1-exercice.

Vous avez trouvé cela difficile ? En cas de doute, consultez la solution sur la branche P3C1-solution.

En résumé

- Plusieurs balises permettent de délimiter les différentes zones qui constituent la page web :

   - <header>  : en-tête ;

   - <footer>  : pied de page ;

   - <nav>  : liens principaux de navigation ;

   - <section>  : section de page ;

   - <aside>  : informations complémentaires ;

   - <article>  : article indépendant.

- Ces balises peuvent être imbriquées les unes dans les autres. Ainsi, une section peut avoir son propre 
  en-tête.

- Ces balises ne s'occupent pas de la mise en page. Elles servent seulement à indiquer à l'ordinateur la 
  fonction du texte qu'elles encadrent. On pourrait très bien placer l'en-tête en bas de la page, si on le 
  souhaitait.

Vous savez maintenant comment structurer correctement vos pages web ! Passons au prochain chapitre : vous allez découvrir le modèle des boîtes, il s'agit d'une autre façon de structurer une page web, mais cette fois à l'aide du CSS, on y va !

##############################################################################################################

Découvrez le modèle des boîtes

Différencier les balises de type  block  et de type  inline

En HTML, la plupart des balises peuvent se ranger dans l'une ou l'autre de ces deux catégories :

  - block: ce type de balise crée automatiquement un retour à la ligne avant et après ; 

  - inline: ce type se trouve obligatoirement à l'intérieur d'une balise  block  . 

Il existe en fait plusieurs autres catégories très spécifiques, par exemple pour les cellules de tableau (type  table-cell  ) ou les puces (type  list-item  ). Nous n'allons pas nous y intéresser pour le moment, car ces balises sont minoritaires.

Pour bien visualiser le concept, voici un petit schéma :

Comme vous pouvez le voir, les blocs sont les uns en dessous des autres. On peut aussi les imbriquer les uns à l'intérieur des autres : souvenez-vous, un bloc  <main>  contient par exemple des blocs  <section>  , qui eux-mêmes peuvent contenir des  <div> .

Quant à la balise  <a></a>  (qui est de type  inline  ), elle se trouve à l'intérieur d'une balise  block  , et le texte vient s'insérer sur la même ligne.

Faites bon usage des balises universelles <span>  et  <div>

J'en profite pour vous parler à nouveau des balises universelles. Vous les connaissez déjà car je vous les ai présentées à plusieurs reprises. Ce sont des balises qui n'ont aucun sens particulier. Le principal intérêt de ces balises est que l'on peut leur appliquer une  class  (ou un  id  ) pour le CSS quand aucune autre balise ne convient.

Il existe deux balises génériques et, comme par hasard, la seule différence entre les deux est que l'une d'elles est  inline  et l'autre est  block  :

    1.La balise<span>(qui est de type inline).

    2.La balise<div>(qui est de type block).

N’abusez pas des balises universelles, même si elles sont utiles dans certains cas : beaucoup de développeurs mettent des  <div>  et des  <span>  trop souvent, et oublient que d'autres balises plus adaptées existent.

Par exemple :

  - <span class="important">  : ici, il ne s'agit pas d'une bonne pratique, alors qu'il existe les balises  
    <strong>   ou  <em>  qui servent à indiquer l'importance ! 

  - <div class="titre">  : idem, cela ne convient pas, puisqu'il existe des balises faites spécialement pour 
    les titres (  <h1>  ,  <h2>  …).

Le résultat visuel est le même, mais les balises génériques n'apportent aucun sens à la page, et ne peuvent pas être comprises par l'ordinateur. Utilisez toujours d'autres balises plus adaptées quand c'est possible.

Maintenant que vous comprenez la différence entre inline et block , nous allons apprendre à dimensionner des éléments en CSS ! Nous allons ici travailler uniquement sur des balises de type  block  .

Pour commencer, intéressons-nous à la taille des blocs.

Dimensionnez les éléments avec width et height

Contrairement à un  inline  , un  block  peut avoir une largeur et une hauteur précises grâce à ces deux propriétés CSS :

  1.width  (largeur du bloc).

  2.height  (hauteur du bloc).

On les exprime en pixels px ou en pourcentage %.

Par défaut, un bloc prend 100 % de la largeur disponible.

On peut le vérifier en appliquant à nos blocs des bordures ou une couleur de fond :

Maintenant, rajoutons un peu de CSS afin de modifier la largeur des paragraphes. Si on veut que tous les paragraphes aient une largeur de 50 %, on écrira en CSS :

p {  
    width: 50%;
}

Le résultat est visible juste en dessous :

Les pourcentages sont utiles pour créer un design qui s'adapte automatiquement à la résolution d'écran du visiteur.

Toutefois, il se peut que vous ayez besoin de créer des blocs ayant une dimension précise en pixels, par exemple pour reprendre un design très précis. Essayez le bout de code suivant pour voir :

p {
    width: 250px;
}

Les images sont un cas un peu particulier : elles se mettent les unes à la suite des autres, sans prendre toute la largeur, mais on peut malgré tout leur donner une dimension exacte.

Définissez des marges avec margin et padding

Tous les blocs possèdent des marges (intérieures et extérieures) :

En CSS, on peut modifier la taille des marges avec deux propriétés :

  1. margin  (taille de la marge extérieure)

  2. padding  (taille de la marge intérieure).

Pour bien comprendre la différence, faisons quelques tests.

Pour l'occasion, j'ai rédigé dans le fichier HTML des paragraphes de texte en lorem ipsum (du faux texte). Ensuite, dans le fichier CSS, j'ai donné au bloc  p  une largeur de  350px  et j'ai ajouté une couleur jaune avec la balise  background-color  pour qu'on visualise bien la différence entre les différentes marges :

p {
    width: 350px;
    background-color: #F1C864;
    text-align: justify;
}

Voilà ce qu'on obtient avec ce code :

Comme vous pouvez le constater, il n'y a par défaut pas de marge intérieure (padding  ) dans le bloc du paragraphe, (on le voit bien car il a un fond jaune et que les bordures sont collées au texte).

En revanche, il y a une marge extérieure (margin  ), on la voit bien car elle espace les paragraphe entre eux, avec une marge blanche (couleur du fond de la page par défaut). C'est cette marge qui fait que deux paragraphes ne sont pas collés, et qu'on a l'impression de “sauter une ligne”.

Ajoutez une marge intérieure avec la propriété CSS  padding
Pour ajouteraux paragraphes une marge intérieure (padding) de  16px  par exemple, on écrit :

p {
    width: 350px;
    background-color: #F1C864;
    text-align: justify;
    padding: 16px;
}

On obtient alors :

Ajoutez une marge extérieure avec la propriété CSS  margin
Maintenant, si on veut que nos paragraphes soient encore plus espacés entre eux, on rajoute la propriété margin  . Demandons par exemple  50px  de marge entre deux paragraphes :

p {
    width: 350px;
    background-color: #F1C864;
    text-align: justify;
    padding: 16px;
    margin: 50px;
}

On obtient :

Mais ??? Une marge s'est rajoutée tout autour aussi, pas seulement entre les deux paragraphes !?

Eh oui, margin  (comme padding  d'ailleurs) s'applique aux quatre côtés du bloc.

Si vous voulez spécifier des marges différentes en haut, en bas, à gauche et à droite, il va falloir utiliser des propriétés plus précises… Le principe est le même que pour la propriété  border, vous allez voir !

Spécifiez les propriétés margin et padding 

Vous allez avoir besoin d'un minimum de vocabulaire en anglais ici :

  - top: haut ;

  - bottom: bas ;

  - left: gauche ;

  - right: droite.

Voyez ce que cela donne dans le schéma ci-dessous :

Vous pouvez aussi utiliser seulement les propriétés raccourcies  margin  ou padding en précisant quatre valeurs à la suite, dans le sens des aiguilles d'une montre (haut, droite, bas, gauche).

Exemple :  margin: 2px 0 3px 1px;.

Ce qui signifie :

“ 2 pixels de marge en haut, 0 pixel de marge à droite (le  px  est facultatif dans ce cas), 3 pixels de marge en bas et 1 pixel de marge à gauche”.

Centrez vos blocs avec  width  et  margin: auto;

Pour centrer des blocs, il faut respecter les règles suivantes :

  1. donner une largeur au bloc avec la propriété width ;

  2. indiquer  margin: auto; (les marges extérieures seront alors automatiques, et permettront de centrer le 
     contenu.

Essayons cette technique sur nos paragraphes, en ajoutant simplement une ligne au CSS :

p {
    width: 350px;
    background-color: #F1C864;
    text-align: justify;
    padding: 16px;
    margin: auto;
}

Et on obtient :

Il n'est cependant pas possible de centrer verticalement un bloc avec cette technique. Seul le centrage horizontal est permis.

Je vous invite maintenant à tester ce que vous venez de découvrir avec le CodePen P3C2.

À vous de jouer !

Vous allez maintenant pouvoir vous faire la main sur le site de Robbie Lens, et mettre en pratique ce que vous venez d'apprendre ! Dans la branche de départ de l'exercice, vous trouverez un bout de CSS qui indique :

* {
    margin: 0;
}

Cela sert à réinitialiser les marges par défaut des navigateurs.

À partir de là, vous allez :

- ajouter un padding au  header  et au  footer  de  20px  en haut et en bas, et de  50px  à gauche et à 
  droite ;

- ajouter une section autour du contenu de la page d'accueil ;

- ajouter une section autour du contenu de la page  A-propos  ;

- donner à vos sections (pour les futures sections à venir) un padding de  80px  ;

- créer un padding de  50px  pour  carre-contenu  ;

- centrer le contenu de la page  A-propos  ;

- aérer le contenu de la page   A-propos  : mettre de la marge au-dessus du sous-titre "Services" et de la 
  liste des compétences. 

Vous trouverez sur GitHub la base de code nécessaire pour réaliser l’exercice sur la branche P3C2-exercice. Voici la solution sur la branche P3C2-solution pour vérifier si vous aviez vu juste.

En résumé

- On distingue deux principaux types de balises en HTML :

    - les balises de type  block  comme  <p>  ou  <h1> créent un retour à la ligne et occupent par défaut 
      toute la largeur disponible. Elles se suivent de haut en bas ;

    - les balises de type  inline  comme  <a>  ou  <strong>  délimitent du texte au milieu d'une ligne. Elles 
      se suivent de gauche à droite.

- On peut modifier la taille d'une balise de type block  avec les propriétés CSS  width (largeur) et  height  
  (hauteur).

- Les éléments de la page disposent chacun de padding (marges intérieures) et de margin  (marges extérieures).

- On peut centrer le contenu d'un bloc dont la largeur est définie par width avec margin: auto;

Ça va ? Vous avez bien digéré toutes les informations ? Alors accrochez-vous ! Dans le chapitre suivant, on va voir une partie essentielle du CSS moderne : Flexbox. Alors à tout de suite !

##############################################################################################################

Faites votre mise en page avec Flexbox

Comprenez la logique : un conteneur, des éléments

Pour faire de la mise en page avec Flexbox, il faut :

  1.Définir un conteneur.

  2.Et placer à l'intérieur plusieurs éléments.

Imaginez un carton dans lequel vous rangez plusieurs objets : c'est le principe !

Sur une même page web, vous pouvez avoir plusieurs conteneurs (plusieurs cartons, si vous préférez). Vous pouvez en créer autant que nécessaire pour obtenir la mise en page que vous voulez.

Commençons par étudier le fonctionnement d'un carton (euh pardon, d'un conteneur).

Un conteneur (container en anglais) est une balise qui peut renfermer d'autres balises, comme du texte ou encore des images. Les conteneurs les plus célèbres sont les balises  <div>  et  <span> .

<div class="container">
<div class="element element1">Élément 1</div>
<div class="element element2">Élément 2</div>
<div class="element element3">Élément 3</div>
</div>

Mais si je fais ça, par défaut, mes éléments vont se mettre les uns en dessous des autres, non ? Ce sont des blocs, après tout !

Oui, tout à fait, c'est le comportement normal dont nous avons l'habitude. Découvrons donc maintenant l'intérêt de Flexbox !

Alignez les éléments d'un conteneur avec  display: flex; 

Il suffit d'une seule propriété CSS, et tout change ! Cette propriété, c'est flex  et on l'applique au conteneur :

.container {
    display: flex;
}

... alors les blocs se placent par défaut côte à côte. Magique !

Donnez leur une direction avec la propriété  flex-direction

Flexbox permet d'agencer ces éléments dans le sens que l'on veut. Avec flex-direction, on peut les positionner verticalement ou encore les inverser. Cette propriété CSS peut prendre les valeurs suivantes :

  - row  : organisés sur une ligne (par défaut) ;

  - column  : organisés sur une colonne ;

  - row-reverse  : organisés sur une ligne, mais en ordre inversé ;

  - column-reverse  : organisés sur une colonne, mais en ordre inversé.

Ici, on fait simplement :

.container {
    display: flex;
    flex-direction: column;
}

Ce qui donne :

Mais mais... c'est pareil qu'au début, non ? On avait ce résultat sans Flexbox, après tout !

C'est vrai. Mais maintenant que nos éléments sont flex, ils ont tout un tas d'autres propriétés utiles que nous allons voir juste après, on va y revenir.

Essayez aussi de tester l'ordre inversé, pour voir :

.container {
    display: flex;
    flex-direction: column-reverse;
}

Et voilà ce que ça donne :

Regardez bien la différence : les blocs sont maintenant dans l'ordre inverse ! Je n'ai pas du tout changé le code HTML, qui reste le même depuis le début.

Retournez à la ligne avec la propriété  flex-wrap

Par défaut, les blocs essaient de rester sur la même ligne s'ils n'ont pas la place, quitte à "s'écraser",  et provoquer parfois des anomalies dans la mise en page (certains éléments pouvant dépasser de leur conteneur). Si vous voulez, vous pouvez demander à ce que les blocs aillent à la ligne lorsqu'ils n'ont plus la place, avec flex-wrap.

Voilà les différentes valeurs de flex-wrap :

nowrap  : pas de retour à la ligne (par défaut) ;

wrap  : les éléments vont à la ligne lorsqu'il n'y a plus la place ;

wrap-reverse  : les éléments vont à la ligne, lorsqu'il n'y a plus la place, en sens inverse.

.container {
    display: flex;
    flex-wrap: nowrap; 
    /* OU wrap;
    OU wrap-reverse; */
}

Dans les illustrations suivantes, vous pouvez voir les différents comportements de nos blocs en fonction de la valeur que l'on attribue à  flex-wrap  : 

Cette propriété sera particulièrement utile quand nous aurons besoin d'adapter nos pages aux plus petits écrans. Nous verrons ça dans la prochaine partie de ce cours.

Alignez les éléments sur un axe principal et secondaire

Les éléments sont organisés par défaut de manière horizontale. Mais ils peuvent être organisés de manière verticale. Selon le choix que vous faîtes, ça va définir ce qu'on appelle l'axe principal. Il y a aussi un axe secondaire :

  - si vos éléments sont organisés horizontalement, l'axe secondaire est l'axe vertical ;

  - si vos éléments sont organisés verticalement, l'axe secondaire est l'axe horizontal.

Pourquoi je vous raconte ça ? Parce que nous allons découvrir comment aligner nos éléments sur l'axe principal et sur l'axe secondaire.

Alignez sur l'axe principal avec la propriété  justify-content

Pour faire simple, partons sur des éléments organisés horizontalement (c'est le cas par défaut).

Pour changer leur alignement, on va utiliser justify-content, qui peut prendre ces valeurs :

  - flex-start: alignés au début (par défaut) ;

  - flex-end: alignés à la fin ;

  - center: alignés au centre ;

  - space-between: les éléments sont étirés sur tout l'axe (il y a de l'espace entre eux) ;

  - space-around: idem, les éléments sont étirés sur tout l'axe, mais ils laissent aussi de l'espace sur les 
    extrémités.

On écrit alors :

.container {
    display: flex;
    justify-content: flex-start /* OU flex-end
    OU center
    OU space-between
    OU space-around; */
}

Le mieux est encore de tester toutes les valeurs possibles pour voir ce que ça donne, vous ne pensez pas ?

Manipulez toutes les valeurs possibles de  justify-content  dans le CodePen P3C3.

Vous voyez comment les éléments s'alignent différemment selon les cas ? Avec une simple propriété, on peut intelligemment agencer nos éléments comme on veut !

Maintenant, voici ce qu'il faut bien comprendre : ça marche aussi si vos éléments sont dans une direction verticale. Dans ce cas, l'axe vertical devient l'axe principal, et justify-content s'applique aussi :

.container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    height: 350px; /* Un peu de hauteur pour que les éléments aient la place de bouger */
}

Avec une direction verticale (“column”), le centrage fonctionne de la même façon, mais cette fois en hauteur.

Ajoutez  flex-direction: column;  dans le CodePen P3C3, vous verrez la différence !

Alignez sur l'axe secondaire avec  align-items
Si nos éléments sont placés dans une direction horizontale (ligne), l'axe secondaire est... vertical. Et inversement : si nos éléments sont dans une direction verticale (colonne), l'axe secondaire est horizontal.

La propriété align-items  permet de changer leur alignement sur l'axe secondaire, grâce aux valeurs :

  - stretch: les éléments sont étirés sur tout l'axe (valeur par défaut) ;

  - flex-start: alignés au début ;

  - flex-end: alignés à la fin ;

  - center: alignés au centre ;

  - baseline: alignés sur la ligne de base (semblable à  flex-start  ).

Pour ces exemples, nous allons partir du principe que nos éléments sont dans une direction horizontale (mais n'hésitez pas à tester aussi dans la direction verticale !).

.container {
    display: flex;
    justify-content: center;
    align-items: center;
}

Ajoutez align-items: center;  dans le CodePen P3C3, vous verrez le résultat !

Saint Graal du développeur web, le centrage vertical et horizontal peut d'ailleurs être obtenu encore plus facilement. Dites-vous que votre conteneur est une Flexbox, et établissez des marges automatiques sur les éléments à l'intérieur. C'est tout ! Essayez :

.container {
    display: flex;
}

.element {
    margin: auto;
}

Répartissez les blocs sur plusieurs lignes avec align-content

Si vous avez plusieurs lignes dans votre Flexbox, vous pouvez choisir comment celles-ci seront réparties avec align-content.

Cette propriété n'a aucun effet s'il n'y a qu'une seule ligne dans la Flexbox.

Prenons donc un cas de figure où nous avons plusieurs lignes. J'autorise les éléments à aller à la ligne avecflex-wrap.

Voyons voir comment les lignes se répartissent différemment avec la nouvelle propriété align-content  que je voulais vous présenter. Elle peut prendre ces valeurs :

  - stretch  (par défaut) : les éléments s'étirent pour occuper tout l'espace ;

  - flex-start  : les éléments sont placés au début ;

  - flex-end  : les éléments sont placés à la fin ;

  - center  : les éléments sont placés au centre ;

  - space-between  : les éléments sont séparés avec de l'espace entre eux ;

  - space-around  : idem, mais il y a aussi de l'espace au début et à la fin.

Amusez-vous avec le CodePen P3C3 pour tester tout cela en remplaçant la propriété  justify-content  par  align-content  !

Et si vous voulez vous entraîner pour vous assurer que vous maîtrisez bien les propriétés de Flexbox, je vous recommande le jeu Flexbox Froggy. Avec les différentes propriétés, vous devrez replacer les grenouilles sur les nénuphars. 

À vous de jouer !